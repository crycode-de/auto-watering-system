/// <reference types="bluebird" />
/// <reference types="node" />
import * as Promise from 'bluebird';
import { RH_Serial } from './RH_Serial';
import { RHDatagram } from './RHDatagram';
/**
 * The acknowledgement bit in the FLAGS.
 */
export declare const RH_FLAGS_ACK = 128;
/**
 * The default retry timeout in milliseconds.
 */
export declare const RH_DEFAULT_TIMEOUT = 200;
/**
 * The default number of retries.
 */
export declare const RH_DEFAULT_RETRIES = 3;
/**
 * RHDatagram subclass for sending addressed, acknowledged, retransmitted datagrams.
 */
export declare class RHReliableDatagram extends RHDatagram {
    /**
     * Count of retransmissions we have had to send
     * @type {number}
     */
    private _retransmissions;
    /**
     * The last sequence number to be used
     * Defaults to 0
     * @type {number}
     */
    private _lastSequenceNumber;
    /**
     * Retransmit timeout (milliseconds)
     * Defaults to 200
     * @type {number}
     */
    private _timeout;
    /**
     * Retries (0 means one try only)
     * Defaults to 3
     * @type {number}
     */
    private _retries;
    /**
     * Array of the last seen sequence number indexed by node address that sent it
     * It is used for duplicate detection. Duplicated messages are re-acknowledged when received
     * (this is generally due to lost ACKs, causing the sender to retransmit, even though we have already
     * received that message)
     * @type {number[]}
     */
    private _seenIds;
    /**
     * Constructor.
     * @param  {RH_Serial} driver      The RadioHead driver to use to transport messages.
     * @param  {number}    thisAddress The address to assign to this node.
     */
    constructor(driver: RH_Serial, thisAddress: number);
    /**
     * Initialise this manager class.
     * @return {Promise}
     */
    init(): Promise<{}>;
    /**
     * Handler for received messages.
     * This sends ack messages and emits the recvfromAck event.
     * @param {RecvMessage} msg The received message to handle.
     */
    private _recvfromAckHandler(msg);
    /**
     * Sets the minimum retransmit timeout. If sendtoWait is waiting for an ack
     * longer than this time (in milliseconds),
     * it will retransmit the message. Defaults to 200ms. The timeout is measured from the end of
     * transmission of the message. It must be at least longer than the the transmit
     * time of the acknowledgement (preamble+6 octets) plus the latency/poll time of the receiver.
     * For fast modulation schemes you can considerably shorten this time.
     * Caution: if you are using slow packet rates and long packets
     * you may need to change the timeout for reliable operations.
     * The actual timeout is randomly varied between timeout and timeout*2.
     * @param {number} timeout The new timeout period in milliseconds
     */
    setTimeout(timeout: number): void;
    /**
     * Sets the maximum number of retries. Defaults to 3 at construction time.
     * If set to 0, each message will only ever be sent once.
     * sendtoWait will give up and reject if there is no ack received after all transmissions time out
     * and the retries count is exhausted.
     * @param  {number} retries The maximum number a retries.
     */
    setRetries(retries: number): void;
    /**
     * Returns the currently configured maximum retries count.
     * Can be changed with setRetries().
     * @return {number} The currently configured maximum number of retries.
     */
    retries(): number;
    /**
     * Send the message (with retries) and waits for an ack. Resolves true if an acknowledgement is received.
     * Rejects if all retries are exhausted (ie up to retries*timeout milliseconds).
     * If the destination address is the broadcast address RH_BROADCAST_ADDRESS (255), the message will
     * be sent as a broadcast, but receiving nodes do not acknowledge, and sendtoWait() resolves immediately
     * without waiting for any acknowledgements.
     * @param  {Buffer}  buf     The buffer to send.
     * @param  {number}  len     Length of the buffer to send.
     * @param  {number}  address The address to send the message to.
     * @return {Promise}
     */
    sendtoWait(buf: Buffer, len: number, address: number): Promise<{}>;
    /**
     * Internal helper function for sendtoWait().
     * @param  {Buffer}  buf     The buffer to send.
     * @param  {number}  len     Length of the buffer to send.
     * @param  {number}  address The address to send the message to.
     * @param  {number}  thisSequenceNumber The headerId for the message.
     * @return {Promise}
     */
    private _sendtoWaitOne(buf, len, address, thisSequenceNumber);
    /**
     * Returns the number of retransmissions
     *  we have had to send since starting or since the last call to resetRetransmissions().
     * @return {number} The number of retransmissions since initialisation.
     */
    retransmissions(): number;
    /**
     * Resets the count of the number of retransmissions to 0.
     */
    resetRetransmissions(): void;
    /**
     * Send an ACK for the message id to the given from address
     * @param  {number} id   The id of the message
     * @param  {number} from From address of the message
     */
    private acknowledge(id, from);
}
