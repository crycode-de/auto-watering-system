"use strict";
/*
 * Node.js module radiohead-serial
 *
 * RadioHead Library (http://www.airspayce.com/mikem/arduino/RadioHead/)
 * Copyright (c) 2014 Mike McCauley
 *
 * Port from native C/C++ code to TypeScript
 * Copyright (c) 2017 Peter MÃ¼ller <peter@crycode.de> (https://crycode.de/)
 */
/// <reference types="node" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var Promise = require("bluebird");
var radiohead_serial_1 = require("./radiohead-serial");
var RHDatagram_1 = require("./RHDatagram");
/**
 * The acknowledgement bit in the FLAGS.
 */
exports.RH_FLAGS_ACK = 0x80;
/**
 * The default retry timeout in milliseconds.
 */
exports.RH_DEFAULT_TIMEOUT = 200;
/**
 * The default number of retries.
 */
exports.RH_DEFAULT_RETRIES = 3;
/**
 * RHDatagram subclass for sending addressed, acknowledged, retransmitted datagrams.
 */
var RHReliableDatagram = (function (_super) {
    __extends(RHReliableDatagram, _super);
    /**
     * Constructor.
     * @param  {RH_Serial} driver      The RadioHead driver to use to transport messages.
     * @param  {number}    thisAddress The address to assign to this node.
     */
    function RHReliableDatagram(driver, thisAddress) {
        var _this = _super.call(this, driver, thisAddress) || this;
        _this._retransmissions = 0;
        _this._lastSequenceNumber = 0;
        _this._timeout = exports.RH_DEFAULT_TIMEOUT;
        _this._retries = exports.RH_DEFAULT_RETRIES;
        _this._seenIds = [];
        for (var i = 0; i < 256; i++) {
            _this._seenIds[i] = 0;
        }
        return _this;
    }
    /**
     * Initialise this manager class.
     * @return {Promise}
     */
    RHReliableDatagram.prototype.init = function () {
        var _this = this;
        return _super.prototype.init.call(this)
            .then(function () {
            // ack messages
            _this.on('recv', _this._recvfromAckHandler.bind(_this));
        });
    };
    /**
     * Handler for received messages.
     * This sends ack messages and emits the recvfromAck event.
     * @param {RecvMessage} msg The received message to handle.
     */
    RHReliableDatagram.prototype._recvfromAckHandler = function (msg) {
        // Never ACK an ACK
        if (!(msg.headerFlags & exports.RH_FLAGS_ACK)) {
            // Its a normal message not an ACK
            if (msg.headerTo === this._thisAddress) {
                // Its for this node and
                // Its not a broadcast, so ACK it
                // Acknowledge message with ACK set in flags and ID set to received ID
                this.acknowledge(msg.headerId, msg.headerFrom);
            }
            // If we have not seen this message before, then we are interested in it
            if (msg.headerId !== this._seenIds[msg.headerFrom]) {
                // emit event for new message
                this.emit('recvfromAck', msg);
                this._seenIds[msg.headerFrom] = msg.headerId;
            }
            // Else just re-ack it
        }
    };
    /**
     * Sets the minimum retransmit timeout. If sendtoWait is waiting for an ack
     * longer than this time (in milliseconds),
     * it will retransmit the message. Defaults to 200ms. The timeout is measured from the end of
     * transmission of the message. It must be at least longer than the the transmit
     * time of the acknowledgement (preamble+6 octets) plus the latency/poll time of the receiver.
     * For fast modulation schemes you can considerably shorten this time.
     * Caution: if you are using slow packet rates and long packets
     * you may need to change the timeout for reliable operations.
     * The actual timeout is randomly varied between timeout and timeout*2.
     * @param {number} timeout The new timeout period in milliseconds
     */
    RHReliableDatagram.prototype.setTimeout = function (timeout) {
        this._timeout = timeout;
    };
    /**
     * Sets the maximum number of retries. Defaults to 3 at construction time.
     * If set to 0, each message will only ever be sent once.
     * sendtoWait will give up and reject if there is no ack received after all transmissions time out
     * and the retries count is exhausted.
     * @param  {number} retries The maximum number a retries.
     */
    RHReliableDatagram.prototype.setRetries = function (retries) {
        this._retries = retries;
    };
    /**
     * Returns the currently configured maximum retries count.
     * Can be changed with setRetries().
     * @return {number} The currently configured maximum number of retries.
     */
    RHReliableDatagram.prototype.retries = function () {
        return this._retries;
    };
    /**
     * Send the message (with retries) and waits for an ack. Resolves true if an acknowledgement is received.
     * Rejects if all retries are exhausted (ie up to retries*timeout milliseconds).
     * If the destination address is the broadcast address RH_BROADCAST_ADDRESS (255), the message will
     * be sent as a broadcast, but receiving nodes do not acknowledge, and sendtoWait() resolves immediately
     * without waiting for any acknowledgements.
     * @param  {Buffer}  buf     The buffer to send.
     * @param  {number}  len     Length of the buffer to send.
     * @param  {number}  address The address to send the message to.
     * @return {Promise}
     */
    RHReliableDatagram.prototype.sendtoWait = function (buf, len, address) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // Assemble the message
            var thisSequenceNumber = ++_this._lastSequenceNumber;
            var retries = 0;
            // promise chain loop with the retries
            var prom;
            var succeeded = function () {
                // _sendtoWaitOne succeeded
                resolve();
            };
            var failed = function (err) {
                // _sendtoWaitOne failed
                if (retries++ <= _this._retries) {
                    // retry
                    _this._retransmissions++;
                    prom.then(function () {
                        return _this._sendtoWaitOne(buf, len, address, thisSequenceNumber).then(succeeded).catch(failed);
                    });
                }
                else {
                    // max retries reached
                    reject(new Error('sendtoWait failed'));
                }
            };
            prom = _this._sendtoWaitOne(buf, len, address, thisSequenceNumber).then(succeeded).catch(failed);
        });
    };
    /**
     * Internal helper function for sendtoWait().
     * @param  {Buffer}  buf     The buffer to send.
     * @param  {number}  len     Length of the buffer to send.
     * @param  {number}  address The address to send the message to.
     * @param  {number}  thisSequenceNumber The headerId for the message.
     * @return {Promise}
     */
    RHReliableDatagram.prototype._sendtoWaitOne = function (buf, len, address, thisSequenceNumber) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.setHeaderId(thisSequenceNumber);
            _this.setHeaderFlags(radiohead_serial_1.RH_FLAGS_NONE, exports.RH_FLAGS_ACK); // Clear the ACK flag
            _this.sendto(buf, len, address)
                .then(function () {
                // Never wait for ACKS to broadcasts:
                if (address === radiohead_serial_1.RH_BROADCAST_ADDRESS) {
                    resolve();
                    return;
                }
                // variable for the ack timeout
                var ackTimeout = null;
                // on ack listener
                var ackListener = function (msg) {
                    if (msg.headerFrom === address
                        && msg.headerTo === _this._thisAddress
                        && (msg.headerFlags & exports.RH_FLAGS_ACK)
                        && msg.headerId === thisSequenceNumber) {
                        // ack received
                        // clear timeout, remove listener and resolve
                        clearTimeout(ackTimeout);
                        _this.removeListener('recv', ackListener);
                        resolve();
                    }
                };
                _this.on('recv', ackListener);
                // Compute a new timeout, random between _timeout and _timeout*2
                // This is to prevent collisions on every retransmit
                // if 2 nodes try to transmit at the same time
                var timeout = _this._timeout + Math.floor(Math.random() * _this._timeout);
                // set ack timeout
                ackTimeout = setTimeout(function () {
                    // ack timed out
                    // remove listener and reject
                    _this.removeListener('recv', ackListener);
                    reject(new Error('ACK timeout'));
                }, timeout);
            })
                .catch(function (err) {
                reject(err);
            });
        });
    };
    /**
     * Returns the number of retransmissions
     *  we have had to send since starting or since the last call to resetRetransmissions().
     * @return {number} The number of retransmissions since initialisation.
     */
    RHReliableDatagram.prototype.retransmissions = function () {
        return this._retransmissions;
    };
    /**
     * Resets the count of the number of retransmissions to 0.
     */
    RHReliableDatagram.prototype.resetRetransmissions = function () {
        this._retransmissions = 0;
    };
    /**
     * Send an ACK for the message id to the given from address
     * @param  {number} id   The id of the message
     * @param  {number} from From address of the message
     */
    RHReliableDatagram.prototype.acknowledge = function (id, from) {
        this.setHeaderId(id);
        this.setHeaderFlags(exports.RH_FLAGS_ACK);
        return this.sendto(new Buffer('!'), 1, from);
    };
    return RHReliableDatagram;
}(RHDatagram_1.RHDatagram));
exports.RHReliableDatagram = RHReliableDatagram;
//# sourceMappingURL=RHReliableDatagram.js.map