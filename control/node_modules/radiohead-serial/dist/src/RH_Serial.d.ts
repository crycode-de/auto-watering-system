/// <reference types="node" />
/// <reference types="bluebird" />
import { EventEmitter } from 'events';
import * as Promise from 'bluebird';
/**
 * Maximum message length (including the headers) we are willing to support
 */
export declare const RH_SERIAL_MAX_PAYLOAD_LEN = 64;
/**
 * The length of the headers we add.
 * The headers are inside the payload and are therefore protected by the FCS
 */
export declare const RH_SERIAL_HEADER_LEN = 4;
/**
 * The maximum message length supported by the RH_Serial driver.
 * This is the largest supported size of a rx or tx buffer.
 */
export declare const RH_SERIAL_MAX_MESSAGE_LEN: number;
/**
 * Driver to send and receive unaddressed, unreliable datagrams via a serial connection
 */
export declare class RH_Serial extends EventEmitter {
    /**
     * The SerialPort we will use
     */
    private _port;
    /**
     * The current state of the Rx state machine
     */
    private _rxState;
    /**
     * Progressive FCS calc (CCITT CRC-16 covering all received data (but not stuffed DLEs), plus trailing DLE, ETX)
     */
    private _rxFcs;
    /**
     * The received FCS at the end of the current message
     */
    private _rxRecdFcs;
    /**
     * Current length of data in the Rx buffer
     */
    private _rxBufLen;
    /**
     * The Rx buffer
     */
    private _rxBuf;
    /**
     * This node id
     */
    private _thisAddress;
    /**
     * Whether the transport is in promiscuous mode
     */
    private _promiscuous;
    /**
     * TO header to send in all messages
     */
    private _txHeaderTo;
    /**
     * FROM header to send in all messages
     */
    private _txHeaderFrom;
    /**
     * ID header to send in all messages
     */
    private _txHeaderId;
    /**
     * FLAGS header to send in all messages
     */
    private _txHeaderFlags;
    /**
     * Constructor
     * @param  {string} port The name of the port we will use. (e.g. /dev/ttyUSB0 or COM1)
     * @param  {number} baud The baud rate we will use.
     */
    constructor(port: string, baud: number);
    /**
     * Initialise the Driver transport hardware and software.
     * @return {Promise} Promise which will be resolved if the SerialPort is opened.
     */
    init(): Promise<{}>;
    /**
     * Close the Driver transport hardware and software.
     * @return {Promise} Promise which will be resolved if the SerialPort is closed.
     */
    close(): Promise<{}>;
    /**
     * Handle a character received from the serial port. Implements
     * the receiver state machine.
     * @param {number} ch One received byte.
     */
    private handleRx(ch);
    /**
     * Empties the Rx buffer.
     */
    protected clearRxBuf(): void;
    /**
     * Adds a charater to the Rx buffer
     * @param  {number} ch The charater.
     */
    protected appendRxBuf(ch: number): void;
    /**
     * Check whether the latest received message is complete and uncorrupted.
     */
    protected validateRxBuf(): void;
    /**
     * Sends data fron a buffer using the currently set headers.
     * Note that a message length of 0 is NOT permitted.
     * @param  {Buffer}  data The buffer containing the data to send.
     * @param  {number}  len  Number of bytes from the buffer to send.
     * @return {Promise}      Promise which will be resolved if sending is completed.
     */
    send(data: Buffer, len: number): Promise<{}>;
    /**
     * Sets the address of this node. Defaults to 0xFF. The user may want to change this.
     * his will be used to test the adddress in incoming messages. In non-promiscuous mode,
     * only messages with a TO header the same as thisAddress or the broadcast addess (0xFF) will be accepted.
     * In promiscuous mode, all messages will be accepted regardless of the TO header.
     * In a conventional multinode system, all nodes will have a unique address.
     * You would normally set the header FROM address to be the same as thisAddress (though you dont have to,
     * allowing the possibilty of address spoofing).
     * @param  {number} address The address of this node.
     */
    setThisAddress(address: number): void;
    /**
     * Sets the TO header to be sent in all subsequent messages.
     * @param {number} to The new TO header value.
     */
    setHeaderTo(to: number): void;
    /**
     * Sets the FROM header to be sent in all subsequent messages.
     * @param {number} from The new FROM header value.
     */
    setHeaderFrom(from: number): void;
    /**
     * Sets the ID header to be sent in all subsequent messages.
     * @param {number} id The new ID header value.
     */
    setHeaderId(id: number): void;
    /**
     * Sets and clears bits in the FLAGS header to be sent in all subsequent messages.
     * First it clears the FLAGS according to the clear argument, then sets the flags according to the
     * set argument. The default for clear always clears the application specific flags.
     * @param {number} set   Bitmask of bits to be set. Flags are cleared with the clear mask before being set.
     * @param {number} clear Bitmask of flags to clear. Defaults to RH_FLAGS_APPLICATION_SPECIFIC which clears the application specific flags, resulting in new application specific flags identical to the set.
     */
    setHeaderFlags(set: number, clear?: number): void;
    /**
     * Tells the receiver to accept messages with any TO address, not just messages
     * addressed to thisAddress or the broadcast address.
     * @param {boolean} promiscuous true if you wish to receive messages with any TO address.
     */
    setPromiscuous(promiscuous: boolean): void;
}
