"use strict";
/*
 * Node.js module radiohead-serial
 *
 * Copyright (c) 2017 Peter Müller <peter@crycode.de> (https://crycode.de/)
 *
 * Node.js module for communication between some RadioHead nodes and Node.js using
 * the RH_Serial driver and the RHReliableDatagram manager of the RadioHead library.
 *
 *
 * RadioHead Library (http://www.airspayce.com/mikem/arduino/RadioHead/)
 * Copyright (c) 2014 Mike McCauley
 *
 * Port from native C/C++ code to TypeScript
 * Copyright (c) 2017 Peter Müller <peter@crycode.de> (https://crycode.de/)
 */
/// <reference types="node" />
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var Promise = require("bluebird");
var RH_Serial_1 = require("./RH_Serial");
exports.RH_Serial = RH_Serial_1.RH_Serial;
exports.RH_SERIAL_MAX_PAYLOAD_LEN = RH_Serial_1.RH_SERIAL_MAX_PAYLOAD_LEN;
exports.RH_SERIAL_HEADER_LEN = RH_Serial_1.RH_SERIAL_HEADER_LEN;
exports.RH_SERIAL_MAX_MESSAGE_LEN = RH_Serial_1.RH_SERIAL_MAX_MESSAGE_LEN;
var RHDatagram_1 = require("./RHDatagram");
exports.RHDatagram = RHDatagram_1.RHDatagram;
var RHReliableDatagram_1 = require("./RHReliableDatagram");
exports.RHReliableDatagram = RHReliableDatagram_1.RHReliableDatagram;
exports.RH_FLAGS_ACK = RHReliableDatagram_1.RH_FLAGS_ACK;
exports.RH_DEFAULT_TIMEOUT = RHReliableDatagram_1.RH_DEFAULT_TIMEOUT;
exports.RH_DEFAULT_RETRIES = RHReliableDatagram_1.RH_DEFAULT_RETRIES;
// export the current version of this module
exports.version = '3.0.1';
/** This is the address that indicates a broadcast */
exports.RH_BROADCAST_ADDRESS = 0xff;
exports.RH_FLAGS_RESERVED = 0xf0;
exports.RH_FLAGS_APPLICATION_SPECIFIC = 0x0f;
exports.RH_FLAGS_NONE = 0;
/**
 * The RadioHeasSerial main class for sending and receiving messages through the RadioHead network.
 */
var RadioHeadSerial = (function (_super) {
    __extends(RadioHeadSerial, _super);
    /**
     * Constructor for a new instance of this class.
     * @param {string}  port     The serial port/device to be used for the communication. (e.g. /dev/ttyUSB0)
     * @param {number}  baud     The baud rate to be used for the communication. (e.g. 9600)
     * @param {number}  address  The address of this node in the RadioHead network. Address range goes from 1 to 254.
     * @param {boolean} reliable (optional) false if RHDatagram should be used instead of RHReliableDatagram. (default true)
     */
    function RadioHeadSerial(port, baud, address, reliable) {
        if (reliable === void 0) { reliable = true; }
        var _this = _super.call(this) || this;
        _this._reliable = reliable;
        _this._driver = new RH_Serial_1.RH_Serial(port, baud);
        // proxy driver errors
        _this._driver.on('error', function (err) {
            _this.emit('error', err);
        });
        if (_this._reliable) {
            _this._manager = new RHReliableDatagram_1.RHReliableDatagram(_this._driver, address);
        }
        else {
            _this._manager = new RHDatagram_1.RHDatagram(_this._driver, address);
        }
        _this._manager.init()
            .then(function () {
            if (_this._reliable) {
                _this._manager.on('recvfromAck', function (message) {
                    _this.emit('data', message);
                });
            }
            else {
                _this._manager.on('recv', function (message) {
                    _this.emit('data', message);
                });
            }
            _this.emit('init-done');
        })
            .catch(function (err) {
            throw err;
        });
        return _this;
    }
    /**
     * Closes the Serialport.
     * After close() is called, no messages can be received.
     * @return {Promise} Promise which will be resolved if the SerialPort is closed.
     */
    RadioHeadSerial.prototype.close = function () {
        return this._driver.close();
    };
    /**
     * Send a message through the RadioHead network.
     * @param  {number} to       Recipient address. Use 255 for broadcast messages.
     * @param  {Buffer} data     Buffer containing the message to send.
     * @param  {number} length   Optional number ob bytes to send from the buffer. If not given the whole buffer is sent.
     * @return {Promise}         A Promise which will be resolved when the message has been sent, or rejected in case of an error.
     */
    RadioHeadSerial.prototype.send = function (to, data, length) {
        if (!length) {
            length = data.length;
        }
        if (length <= 0) {
            return Promise.reject(new Error('Nothing to send'));
        }
        if (this._reliable) {
            return this._manager.sendtoWait(data, length, to);
        }
        else {
            return this._manager.sendto(data, length, to);
        }
    };
    /**
     * Set the address of this node in the RadioHead network.
     * @param {number} address The new address.
     */
    RadioHeadSerial.prototype.setAddress = function (address) {
        this._manager.setThisAddress(address);
    };
    /**
     * Returns the address of this node.
     * @return {number} The address of this node.
     */
    RadioHeadSerial.prototype.thisAddress = function () {
        return this._manager.thisAddress();
    };
    /**
     * Sets the maximum number of retries.
     * Defaults to 3 at construction time.
     * If set to 0, each message will only ever be sent once.
     * @param {number} count New number of retries.
     */
    RadioHeadSerial.prototype.setRetries = function (count) {
        if (!this._reliable)
            return;
        this._manager.setRetries(count);
    };
    /**
     * Returns the currently configured maximum retries count.
     * Can be changed with setRetries().
     * @return {number} The currently configured maximum retries count.
     */
    RadioHeadSerial.prototype.getRetries = function () {
        if (!this._reliable)
            return 0;
        return this._manager.retries();
    };
    /**
     * Sets the minimum retransmit timeout in milliseconds.
     * If an ack is taking longer than this time, a message will be retransmitted.
     * Default is 200.
     * @param {number} timeout New timeout in milliseconds.
     */
    RadioHeadSerial.prototype.setTimeout = function (timeout) {
        if (!this._reliable)
            return;
        this._manager.setTimeout(timeout);
    };
    /**
     * Returns the number of retransmissions we have had to send since starting
     * or since the last call to resetRetransmissions().
     * @return {number} The number of retransmissions we have had to send since starting.
     */
    RadioHeadSerial.prototype.getRetransmissions = function () {
        if (!this._reliable)
            return 0;
        return this._manager.retransmissions();
    };
    /**
     * Resets the count of the number of retransmissions to 0.
     */
    RadioHeadSerial.prototype.resetRetransmissions = function () {
        if (!this._reliable)
            return;
        this._manager.resetRetransmissions();
    };
    /**
     * Tells the receiver to accept messages with any to address, not just messages addressed to this node or the broadcast address.
     * @param {boolean} promiscuous true if you wish to receive messages with any to address. (default false)
     */
    RadioHeadSerial.prototype.setPromiscuous = function (promiscuous) {
        this._driver.setPromiscuous(promiscuous);
    };
    return RadioHeadSerial;
}(events_1.EventEmitter));
exports.RadioHeadSerial = RadioHeadSerial;
//# sourceMappingURL=radiohead-serial.js.map